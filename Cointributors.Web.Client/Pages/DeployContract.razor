@rendermode @(new InteractiveWebAssemblyRenderMode(prerender:false))

@using System.Security.Claims
@using Cointributors.Web.Client.Contract.CointributionSplitter.ContractDefinition
@using Cointributors.Web.Client.Data
@implements IDisposable
@inject IJSRuntime jsRuntime
@inject SelectedEthereumHostProviderService selectedHostProviderService
@inject NavigationManager navigationManager
@inject AuthenticationStateProvider siweAuthenticationStateProvider

<AuthorizeView Roles="EthereumConnected">
    <Authorized>
        <div>
            Ethereum connected!
        </div>
        <button @onclick="@Deploy" class="btn btn-primary">Deploy</button>
        <div>
            @contractAddress
        </div>
    </Authorized>
    <NotAuthorized>
        <div>
            Please connect to Ethereum!
        </div>
    </NotAuthorized>
</AuthorizeView>

@code {

    [CascadingParameter]
    public Task<AuthenticationState?> AuthenticationState { get; set; }

    [Parameter]
    public CointributorsData CointributorsData { get; set; }

    private bool ethereumAvailable;
    private string selectedAccount;
    private long selectedChainId;
    private string userName;
    private string contractAddress;

    IEthereumHostProvider ethereumHostProvider;

    protected override void OnInitialized()
    {
        //metamask is selected
        ethereumHostProvider = selectedHostProviderService.SelectedHost;
        ethereumHostProvider.SelectedAccountChanged += OnSelectedAccountChanged;
        ethereumHostProvider.NetworkChanged += OnNetworkChanged;
        ethereumHostProvider.EnabledChanged += OnEnabledChanged;

    }

    public void Dispose()
    {
        ethereumHostProvider.SelectedAccountChanged -= OnSelectedAccountChanged;
        ethereumHostProvider.NetworkChanged -= OnNetworkChanged;
        ethereumHostProvider.EnabledChanged -= OnEnabledChanged;
    }

    protected override async Task OnInitializedAsync()
    {
        ethereumAvailable = await ethereumHostProvider.CheckProviderAvailabilityAsync();
        if (ethereumAvailable)
        {
            selectedAccount = await ethereumHostProvider.GetProviderSelectedAccountAsync();
        }

        var authState = await AuthenticationState;
        if (authState != null)
        {
            userName = authState.User.FindFirst(c => c.Type.Contains(ClaimTypes.NameIdentifier))?.Value;
        }
    }

    private async Task OnSelectedAccountChanged(string account)
    {
        selectedAccount = account;
        StateHasChanged();
    }

    private async Task OnNetworkChanged(long chainId)
    {
        selectedChainId = chainId;
        StateHasChanged();
    }

    private async Task OnEnabledChanged(bool enabled)
    {
        if (enabled)
        {
            await GetChainId();
            StateHasChanged();
        }
    }

    private async Task GetChainId()
    {
        var web3 = await ethereumHostProvider.GetWeb3Async();
        var chainId = await web3.Eth.ChainId.SendRequestAsync();
        selectedChainId = (long)chainId.Value;
    }

    protected async Task Deploy()
    {
        if (CointributorsData != null)
        {
            var web3 = await ethereumHostProvider.GetWeb3Async();
            var deployment = new CointributionSplitterDeployment
            {
                Recipients = []
            };

            foreach (var allocation in CointributorsData.Allocations)
            {
                deployment.Recipients.Add(new Recipient
                {
                    RecipientAddress = allocation.Address,
                    Portion = allocation.Allocation * 100, // Convert to bps
                    IsSplitter = allocation.Type == DestinationType.Dependency
                });
            }

            var transactionReceipt = await web3.Eth.GetContractDeploymentHandler<CointributionSplitterDeployment>()
                .SendRequestAndWaitForReceiptAsync(deployment);

            contractAddress = transactionReceipt.ContractAddress;
        }
    }
}
